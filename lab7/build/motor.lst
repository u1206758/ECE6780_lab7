ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 1


   1              		.cpu cortex-m0
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"motor.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.pwm_init,"ax",%progbits
  16              		.align	1
  17              		.global	pwm_init
  18              		.arch armv6s-m
  19              		.syntax unified
  20              		.code	16
  21              		.thumb_func
  22              		.fpu softvfp
  24              	pwm_init:
  25              	.LFB44:
  26              		.file 1 "Src/motor.c"
   1:Src/motor.c   **** /* ------------------------------------------------------------------------------------------------
   2:Src/motor.c   ****  *  Motor Control and Initialization Functions
   3:Src/motor.c   ****  * ------------------------------------------------------------------------------------------------
   4:Src/motor.c   ****  */
   5:Src/motor.c   **** #include "motor.h"
   6:Src/motor.c   **** 
   7:Src/motor.c   **** volatile int16_t error_integral = 0;    // Integrated error signal
   8:Src/motor.c   **** volatile uint8_t duty_cycle = 0;    	// Output PWM duty cycle
   9:Src/motor.c   **** volatile int16_t target_rpm = 0;    	// Desired speed target
  10:Src/motor.c   **** volatile int16_t motor_speed = 0;   	// Measured motor speed
  11:Src/motor.c   **** volatile int8_t adc_value = 0;      	// ADC measured motor current
  12:Src/motor.c   **** volatile int16_t error = 0;         	// Speed error signal
  13:Src/motor.c   **** volatile uint8_t Kp = 10;            	// Proportional gain
  14:Src/motor.c   **** volatile uint8_t Ki = 10;            	// Integral gain
  15:Src/motor.c   **** 
  16:Src/motor.c   **** // Sets up the entire motor drive system
  17:Src/motor.c   **** void motor_init(void) {
  18:Src/motor.c   ****     pwm_init();
  19:Src/motor.c   ****     encoder_init();
  20:Src/motor.c   ****     ADC_init();
  21:Src/motor.c   **** }
  22:Src/motor.c   **** 
  23:Src/motor.c   **** // Sets up the PWM and direction signals to drive the H-Bridge
  24:Src/motor.c   **** void pwm_init(void) {
  27              		.loc 1 24 21 view -0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  25:Src/motor.c   ****     
  26:Src/motor.c   ****     // Set up pin PA4 for H-bridge PWM output (TIMER 14 CH1)
  27:Src/motor.c   ****     GPIOA->MODER |= (1 << 9);
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 2


  32              		.loc 1 27 5 view .LVU1
  33              		.loc 1 27 18 is_stmt 0 view .LVU2
  34 0000 9023     		movs	r3, #144
  35 0002 DB05     		lsls	r3, r3, #23
  36 0004 1968     		ldr	r1, [r3]
  37 0006 8022     		movs	r2, #128
  38 0008 9200     		lsls	r2, r2, #2
  39 000a 0A43     		orrs	r2, r1
  40 000c 1A60     		str	r2, [r3]
  28:Src/motor.c   ****     GPIOA->MODER &= ~(1 << 8);
  41              		.loc 1 28 5 is_stmt 1 view .LVU3
  42              		.loc 1 28 18 is_stmt 0 view .LVU4
  43 000e 1A68     		ldr	r2, [r3]
  44 0010 1C49     		ldr	r1, .L2
  45 0012 0A40     		ands	r2, r1
  46 0014 1A60     		str	r2, [r3]
  29:Src/motor.c   **** 
  30:Src/motor.c   ****     // Set PA4 to AF4,
  31:Src/motor.c   ****     GPIOA->AFR[0] &= 0xFFF0FFFF; // clear PA4 bits,
  47              		.loc 1 31 5 is_stmt 1 view .LVU5
  48              		.loc 1 31 19 is_stmt 0 view .LVU6
  49 0016 1A6A     		ldr	r2, [r3, #32]
  50 0018 1B49     		ldr	r1, .L2+4
  51 001a 0A40     		ands	r2, r1
  52 001c 1A62     		str	r2, [r3, #32]
  32:Src/motor.c   ****     GPIOA->AFR[0] |= (1 << 18);
  53              		.loc 1 32 5 is_stmt 1 view .LVU7
  54              		.loc 1 32 19 is_stmt 0 view .LVU8
  55 001e 196A     		ldr	r1, [r3, #32]
  56 0020 8022     		movs	r2, #128
  57 0022 D202     		lsls	r2, r2, #11
  58 0024 0A43     		orrs	r2, r1
  59 0026 1A62     		str	r2, [r3, #32]
  33:Src/motor.c   **** 
  34:Src/motor.c   ****     // Set up a PA5, PA6 as GPIO output pins for motor direction control
  35:Src/motor.c   ****     GPIOA->MODER &= 0xFFFFC3FF; // clear PA5, PA6 bits,
  60              		.loc 1 35 5 is_stmt 1 view .LVU9
  61              		.loc 1 35 18 is_stmt 0 view .LVU10
  62 0028 1A68     		ldr	r2, [r3]
  63 002a 1849     		ldr	r1, .L2+8
  64 002c 0A40     		ands	r2, r1
  65 002e 1A60     		str	r2, [r3]
  36:Src/motor.c   ****     GPIOA->MODER |= (1 << 10) | (1 << 12);
  66              		.loc 1 36 5 is_stmt 1 view .LVU11
  67              		.loc 1 36 18 is_stmt 0 view .LVU12
  68 0030 1968     		ldr	r1, [r3]
  69 0032 A022     		movs	r2, #160
  70 0034 5201     		lsls	r2, r2, #5
  71 0036 0A43     		orrs	r2, r1
  72 0038 1A60     		str	r2, [r3]
  37:Src/motor.c   ****     
  38:Src/motor.c   ****     //Initialize one direction pin to high, the other low
  39:Src/motor.c   ****     GPIOA->ODR |= (1 << 5);
  73              		.loc 1 39 5 is_stmt 1 view .LVU13
  74              		.loc 1 39 16 is_stmt 0 view .LVU14
  75 003a 5A69     		ldr	r2, [r3, #20]
  76 003c 2021     		movs	r1, #32
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 3


  77 003e 0A43     		orrs	r2, r1
  78 0040 5A61     		str	r2, [r3, #20]
  40:Src/motor.c   ****     GPIOA->ODR &= ~(1 << 6);
  79              		.loc 1 40 5 is_stmt 1 view .LVU15
  80              		.loc 1 40 16 is_stmt 0 view .LVU16
  81 0042 5A69     		ldr	r2, [r3, #20]
  82 0044 2031     		adds	r1, r1, #32
  83 0046 8A43     		bics	r2, r1
  84 0048 5A61     		str	r2, [r3, #20]
  41:Src/motor.c   **** 
  42:Src/motor.c   ****     // Set up PWM timer
  43:Src/motor.c   ****     RCC->APB1ENR |= RCC_APB1ENR_TIM14EN;
  85              		.loc 1 43 5 is_stmt 1 view .LVU17
  86              		.loc 1 43 18 is_stmt 0 view .LVU18
  87 004a 114A     		ldr	r2, .L2+12
  88 004c D169     		ldr	r1, [r2, #28]
  89 004e 8023     		movs	r3, #128
  90 0050 5B00     		lsls	r3, r3, #1
  91 0052 0B43     		orrs	r3, r1
  92 0054 D361     		str	r3, [r2, #28]
  44:Src/motor.c   ****     TIM14->CR1 = 0;                         // Clear control registers
  93              		.loc 1 44 5 is_stmt 1 view .LVU19
  94              		.loc 1 44 16 is_stmt 0 view .LVU20
  95 0056 0F4B     		ldr	r3, .L2+16
  96 0058 0022     		movs	r2, #0
  97 005a 1A60     		str	r2, [r3]
  45:Src/motor.c   ****     TIM14->CCMR1 = 0;                       // (prevents having to manually clear bits)
  98              		.loc 1 45 5 is_stmt 1 view .LVU21
  99              		.loc 1 45 18 is_stmt 0 view .LVU22
 100 005c 9A61     		str	r2, [r3, #24]
  46:Src/motor.c   ****     TIM14->CCER = 0;
 101              		.loc 1 46 5 is_stmt 1 view .LVU23
 102              		.loc 1 46 17 is_stmt 0 view .LVU24
 103 005e 1A62     		str	r2, [r3, #32]
  47:Src/motor.c   **** 
  48:Src/motor.c   ****     // Set output-compare CH1 to PWM1 mode and enable CCR1 preload buffer
  49:Src/motor.c   ****     TIM14->CCMR1 |= (TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1PE);
 104              		.loc 1 49 5 is_stmt 1 view .LVU25
 105              		.loc 1 49 18 is_stmt 0 view .LVU26
 106 0060 9969     		ldr	r1, [r3, #24]
 107 0062 6820     		movs	r0, #104
 108 0064 0143     		orrs	r1, r0
 109 0066 9961     		str	r1, [r3, #24]
  50:Src/motor.c   ****     TIM14->CCER |= TIM_CCER_CC1E;           // Enable capture-compare channel 1
 110              		.loc 1 50 5 is_stmt 1 view .LVU27
 111              		.loc 1 50 17 is_stmt 0 view .LVU28
 112 0068 186A     		ldr	r0, [r3, #32]
 113 006a 0121     		movs	r1, #1
 114 006c 0843     		orrs	r0, r1
 115 006e 1862     		str	r0, [r3, #32]
  51:Src/motor.c   ****     TIM14->PSC = 1;                         // Run timer on 24Mhz
 116              		.loc 1 51 5 is_stmt 1 view .LVU29
 117              		.loc 1 51 16 is_stmt 0 view .LVU30
 118 0070 9962     		str	r1, [r3, #40]
  52:Src/motor.c   ****     TIM14->ARR = 1200;                      // PWM at 20kHz
 119              		.loc 1 52 5 is_stmt 1 view .LVU31
 120              		.loc 1 52 16 is_stmt 0 view .LVU32
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 4


 121 0072 9620     		movs	r0, #150
 122 0074 C000     		lsls	r0, r0, #3
 123 0076 D862     		str	r0, [r3, #44]
  53:Src/motor.c   ****     TIM14->CCR1 = 0;                        // Start PWM at 0% duty cycle
 124              		.loc 1 53 5 is_stmt 1 view .LVU33
 125              		.loc 1 53 17 is_stmt 0 view .LVU34
 126 0078 5A63     		str	r2, [r3, #52]
  54:Src/motor.c   ****     
  55:Src/motor.c   ****     TIM14->CR1 |= TIM_CR1_CEN;              // Enable timer
 127              		.loc 1 55 5 is_stmt 1 view .LVU35
 128              		.loc 1 55 16 is_stmt 0 view .LVU36
 129 007a 1A68     		ldr	r2, [r3]
 130 007c 0A43     		orrs	r2, r1
 131 007e 1A60     		str	r2, [r3]
  56:Src/motor.c   **** }
 132              		.loc 1 56 1 view .LVU37
 133              		@ sp needed
 134 0080 7047     		bx	lr
 135              	.L3:
 136 0082 C046     		.align	2
 137              	.L2:
 138 0084 FFFEFFFF 		.word	-257
 139 0088 FFFFF0FF 		.word	-983041
 140 008c FFC3FFFF 		.word	-15361
 141 0090 00100240 		.word	1073876992
 142 0094 00200040 		.word	1073750016
 143              		.cfi_endproc
 144              	.LFE44:
 146              		.global	__aeabi_uidiv
 147              		.section	.text.pwm_setDutyCycle,"ax",%progbits
 148              		.align	1
 149              		.global	pwm_setDutyCycle
 150              		.syntax unified
 151              		.code	16
 152              		.thumb_func
 153              		.fpu softvfp
 155              	pwm_setDutyCycle:
 156              	.LVL0:
 157              	.LFB45:
  57:Src/motor.c   **** 
  58:Src/motor.c   **** // Set the duty cycle of the PWM, accepts (0-100)
  59:Src/motor.c   **** void pwm_setDutyCycle(uint8_t duty) {
 158              		.loc 1 59 37 is_stmt 1 view -0
 159              		.cfi_startproc
 160              		@ args = 0, pretend = 0, frame = 0
 161              		@ frame_needed = 0, uses_anonymous_args = 0
 162              		.loc 1 59 37 is_stmt 0 view .LVU39
 163 0000 10B5     		push	{r4, lr}
 164              	.LCFI0:
 165              		.cfi_def_cfa_offset 8
 166              		.cfi_offset 4, -8
 167              		.cfi_offset 14, -4
  60:Src/motor.c   ****     if(duty <= 100) {
 168              		.loc 1 60 5 is_stmt 1 view .LVU40
 169              		.loc 1 60 7 is_stmt 0 view .LVU41
 170 0002 6428     		cmp	r0, #100
 171 0004 06D8     		bhi	.L4
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 5


  61:Src/motor.c   ****         TIM14->CCR1 = ((uint32_t)duty*TIM14->ARR)/100;  // Use linear transform to produce CCR1 val
 172              		.loc 1 61 9 is_stmt 1 view .LVU42
 173              		.loc 1 61 44 is_stmt 0 view .LVU43
 174 0006 044C     		ldr	r4, .L6
 175 0008 E36A     		ldr	r3, [r4, #44]
 176              		.loc 1 61 38 view .LVU44
 177 000a 5843     		muls	r0, r3
 178              	.LVL1:
 179              		.loc 1 61 50 view .LVU45
 180 000c 6421     		movs	r1, #100
 181 000e FFF7FEFF 		bl	__aeabi_uidiv
 182              	.LVL2:
 183              		.loc 1 61 21 view .LVU46
 184 0012 6063     		str	r0, [r4, #52]
 185              	.L4:
  62:Src/motor.c   ****         // (CCR1 == "pulse" parameter in PWM struct used by peripheral library)
  63:Src/motor.c   ****     }
  64:Src/motor.c   **** }
 186              		.loc 1 64 1 view .LVU47
 187              		@ sp needed
 188 0014 10BD     		pop	{r4, pc}
 189              	.L7:
 190 0016 C046     		.align	2
 191              	.L6:
 192 0018 00200040 		.word	1073750016
 193              		.cfi_endproc
 194              	.LFE45:
 196              		.section	.text.encoder_init,"ax",%progbits
 197              		.align	1
 198              		.global	encoder_init
 199              		.syntax unified
 200              		.code	16
 201              		.thumb_func
 202              		.fpu softvfp
 204              	encoder_init:
 205              	.LFB46:
  65:Src/motor.c   **** 
  66:Src/motor.c   **** // Sets up encoder interface to read motor speed
  67:Src/motor.c   **** void encoder_init(void) {
 206              		.loc 1 67 25 is_stmt 1 view -0
 207              		.cfi_startproc
 208              		@ args = 0, pretend = 0, frame = 0
 209              		@ frame_needed = 0, uses_anonymous_args = 0
 210              		@ link register save eliminated.
  68:Src/motor.c   ****     
  69:Src/motor.c   ****     // Set up encoder input pins (TIMER 3 CH1 and CH2)
  70:Src/motor.c   ****     RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
 211              		.loc 1 70 5 view .LVU49
 212              		.loc 1 70 17 is_stmt 0 view .LVU50
 213 0000 264A     		ldr	r2, .L9
 214 0002 5169     		ldr	r1, [r2, #20]
 215 0004 8023     		movs	r3, #128
 216 0006 DB02     		lsls	r3, r3, #11
 217 0008 0B43     		orrs	r3, r1
 218 000a 5361     		str	r3, [r2, #20]
  71:Src/motor.c   **** 
  72:Src/motor.c   ****     GPIOB->MODER &= ~(GPIO_MODER_MODER4_0 | GPIO_MODER_MODER5_0);
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 6


 219              		.loc 1 72 5 is_stmt 1 view .LVU51
 220              		.loc 1 72 18 is_stmt 0 view .LVU52
 221 000c 244B     		ldr	r3, .L9+4
 222 000e 1968     		ldr	r1, [r3]
 223 0010 2448     		ldr	r0, .L9+8
 224 0012 0140     		ands	r1, r0
 225 0014 1960     		str	r1, [r3]
  73:Src/motor.c   ****     GPIOB->MODER |= (GPIO_MODER_MODER4_1 | GPIO_MODER_MODER5_1);
 226              		.loc 1 73 5 is_stmt 1 view .LVU53
 227              		.loc 1 73 18 is_stmt 0 view .LVU54
 228 0016 1868     		ldr	r0, [r3]
 229 0018 A021     		movs	r1, #160
 230 001a 0901     		lsls	r1, r1, #4
 231 001c 0143     		orrs	r1, r0
 232 001e 1960     		str	r1, [r3]
  74:Src/motor.c   ****     GPIOB->AFR[0] |= ( (1 << 16) | (1 << 20) );
 233              		.loc 1 74 5 is_stmt 1 view .LVU55
 234              		.loc 1 74 19 is_stmt 0 view .LVU56
 235 0020 186A     		ldr	r0, [r3, #32]
 236 0022 8821     		movs	r1, #136
 237 0024 4903     		lsls	r1, r1, #13
 238 0026 0143     		orrs	r1, r0
 239 0028 1962     		str	r1, [r3, #32]
  75:Src/motor.c   **** 
  76:Src/motor.c   ****     // Set up encoder interface (TIM3 encoder input mode)
  77:Src/motor.c   ****     RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
 240              		.loc 1 77 5 is_stmt 1 view .LVU57
 241              		.loc 1 77 18 is_stmt 0 view .LVU58
 242 002a D369     		ldr	r3, [r2, #28]
 243 002c 0221     		movs	r1, #2
 244 002e 0B43     		orrs	r3, r1
 245 0030 D361     		str	r3, [r2, #28]
  78:Src/motor.c   ****     TIM3->CCMR1 = 0;
 246              		.loc 1 78 5 is_stmt 1 view .LVU59
 247              		.loc 1 78 17 is_stmt 0 view .LVU60
 248 0032 1D4B     		ldr	r3, .L9+12
 249 0034 0021     		movs	r1, #0
 250 0036 9961     		str	r1, [r3, #24]
  79:Src/motor.c   ****     TIM3->CCER = 0;
 251              		.loc 1 79 5 is_stmt 1 view .LVU61
 252              		.loc 1 79 16 is_stmt 0 view .LVU62
 253 0038 1962     		str	r1, [r3, #32]
  80:Src/motor.c   ****     TIM3->SMCR = 0;
 254              		.loc 1 80 5 is_stmt 1 view .LVU63
 255              		.loc 1 80 16 is_stmt 0 view .LVU64
 256 003a 9960     		str	r1, [r3, #8]
  81:Src/motor.c   ****     TIM3->CR1 = 0;
 257              		.loc 1 81 5 is_stmt 1 view .LVU65
 258              		.loc 1 81 15 is_stmt 0 view .LVU66
 259 003c 1960     		str	r1, [r3]
  82:Src/motor.c   **** 
  83:Src/motor.c   ****     TIM3->CCMR1 |= (TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0);   // TI1FP1 and TI2FP2 signals connected 
 260              		.loc 1 83 5 is_stmt 1 view .LVU67
 261              		.loc 1 83 17 is_stmt 0 view .LVU68
 262 003e 9869     		ldr	r0, [r3, #24]
 263 0040 0221     		movs	r1, #2
 264 0042 FF31     		adds	r1, r1, #255
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 7


 265 0044 0143     		orrs	r1, r0
 266 0046 9961     		str	r1, [r3, #24]
  84:Src/motor.c   ****     TIM3->SMCR |= (TIM_SMCR_SMS_1 | TIM_SMCR_SMS_0);        // Capture encoder on both rising and f
 267              		.loc 1 84 5 is_stmt 1 view .LVU69
 268              		.loc 1 84 16 is_stmt 0 view .LVU70
 269 0048 9968     		ldr	r1, [r3, #8]
 270 004a 0320     		movs	r0, #3
 271 004c 0143     		orrs	r1, r0
 272 004e 9960     		str	r1, [r3, #8]
  85:Src/motor.c   ****     TIM3->ARR = 0xFFFF;                                     // Set ARR to top of timer (longest pos
 273              		.loc 1 85 5 is_stmt 1 view .LVU71
 274              		.loc 1 85 15 is_stmt 0 view .LVU72
 275 0050 1649     		ldr	r1, .L9+16
 276 0052 D962     		str	r1, [r3, #44]
  86:Src/motor.c   ****     TIM3->CNT = 0x7FFF;                                     // Bias at midpoint to allow for negati
 277              		.loc 1 86 5 is_stmt 1 view .LVU73
 278              		.loc 1 86 15 is_stmt 0 view .LVU74
 279 0054 1649     		ldr	r1, .L9+20
 280 0056 5962     		str	r1, [r3, #36]
  87:Src/motor.c   ****     // (Could also cast unsigned register to signed number to get negative numbers if it rotates ba
  88:Src/motor.c   ****     //  just another option, the mid-bias is a bit simpler to understand though.)
  89:Src/motor.c   ****     TIM3->CR1 |= TIM_CR1_CEN;                               // Enable timer
 281              		.loc 1 89 5 is_stmt 1 view .LVU75
 282              		.loc 1 89 15 is_stmt 0 view .LVU76
 283 0058 1868     		ldr	r0, [r3]
 284 005a 0121     		movs	r1, #1
 285 005c 0843     		orrs	r0, r1
 286 005e 1860     		str	r0, [r3]
  90:Src/motor.c   **** 
  91:Src/motor.c   ****     // Configure a second timer (TIM6) to fire an ISR on update event
  92:Src/motor.c   ****     // Used to periodically check and update speed variable
  93:Src/motor.c   ****     RCC->APB1ENR |= RCC_APB1ENR_TIM6EN;
 287              		.loc 1 93 5 is_stmt 1 view .LVU77
 288              		.loc 1 93 18 is_stmt 0 view .LVU78
 289 0060 D369     		ldr	r3, [r2, #28]
 290 0062 1020     		movs	r0, #16
 291 0064 0343     		orrs	r3, r0
 292 0066 D361     		str	r3, [r2, #28]
  94:Src/motor.c   ****     
  95:Src/motor.c   ****     // Select PSC and ARR values that give an appropriate interrupt rate
  96:Src/motor.c   ****     //500 kHz, 2 us between ticks, 5:1 ratio between encoder count and output RPM
  97:Src/motor.c   ****     //TIM6->PSC = 15;
  98:Src/motor.c   ****     //TIM6->ARR = 46875;
  99:Src/motor.c   ****     TIM6->PSC = 11;
 293              		.loc 1 99 5 is_stmt 1 view .LVU79
 294              		.loc 1 99 15 is_stmt 0 view .LVU80
 295 0068 124B     		ldr	r3, .L9+24
 296 006a 0B22     		movs	r2, #11
 297 006c 9A62     		str	r2, [r3, #40]
 100:Src/motor.c   ****     TIM6->ARR = 30000;
 298              		.loc 1 100 5 is_stmt 1 view .LVU81
 299              		.loc 1 100 15 is_stmt 0 view .LVU82
 300 006e 124A     		ldr	r2, .L9+28
 301 0070 DA62     		str	r2, [r3, #44]
 101:Src/motor.c   ****    
 102:Src/motor.c   **** 
 103:Src/motor.c   ****     TIM6->DIER |= TIM_DIER_UIE;             // Enable update event interrupt
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 8


 302              		.loc 1 103 5 is_stmt 1 view .LVU83
 303              		.loc 1 103 16 is_stmt 0 view .LVU84
 304 0072 DA68     		ldr	r2, [r3, #12]
 305 0074 0A43     		orrs	r2, r1
 306 0076 DA60     		str	r2, [r3, #12]
 104:Src/motor.c   ****     TIM6->CR1 |= TIM_CR1_CEN;               // Enable Timer
 307              		.loc 1 104 5 is_stmt 1 view .LVU85
 308              		.loc 1 104 15 is_stmt 0 view .LVU86
 309 0078 1A68     		ldr	r2, [r3]
 310 007a 0A43     		orrs	r2, r1
 311 007c 1A60     		str	r2, [r3]
 105:Src/motor.c   **** 
 106:Src/motor.c   ****     NVIC_EnableIRQ(TIM6_DAC_IRQn);          // Enable interrupt in NVIC
 312              		.loc 1 106 5 is_stmt 1 view .LVU87
 313              	.LVL3:
 314              	.LBB6:
 315              	.LBI6:
 316              		.file 2 "Drivers/CMSIS/Include/core_cm0.h"
   1:Drivers/CMSIS/Include/core_cm0.h **** /**************************************************************************//**
   2:Drivers/CMSIS/Include/core_cm0.h ****  * @file     core_cm0.h
   3:Drivers/CMSIS/Include/core_cm0.h ****  * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
   4:Drivers/CMSIS/Include/core_cm0.h ****  * @version  V5.0.5
   5:Drivers/CMSIS/Include/core_cm0.h ****  * @date     28. May 2018
   6:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
   7:Drivers/CMSIS/Include/core_cm0.h **** /*
   8:Drivers/CMSIS/Include/core_cm0.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:Drivers/CMSIS/Include/core_cm0.h ****  *
  10:Drivers/CMSIS/Include/core_cm0.h ****  * SPDX-License-Identifier: Apache-2.0
  11:Drivers/CMSIS/Include/core_cm0.h ****  *
  12:Drivers/CMSIS/Include/core_cm0.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:Drivers/CMSIS/Include/core_cm0.h ****  * not use this file except in compliance with the License.
  14:Drivers/CMSIS/Include/core_cm0.h ****  * You may obtain a copy of the License at
  15:Drivers/CMSIS/Include/core_cm0.h ****  *
  16:Drivers/CMSIS/Include/core_cm0.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:Drivers/CMSIS/Include/core_cm0.h ****  *
  18:Drivers/CMSIS/Include/core_cm0.h ****  * Unless required by applicable law or agreed to in writing, software
  19:Drivers/CMSIS/Include/core_cm0.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:Drivers/CMSIS/Include/core_cm0.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:Drivers/CMSIS/Include/core_cm0.h ****  * See the License for the specific language governing permissions and
  22:Drivers/CMSIS/Include/core_cm0.h ****  * limitations under the License.
  23:Drivers/CMSIS/Include/core_cm0.h ****  */
  24:Drivers/CMSIS/Include/core_cm0.h **** 
  25:Drivers/CMSIS/Include/core_cm0.h **** #if   defined ( __ICCARM__ )
  26:Drivers/CMSIS/Include/core_cm0.h ****   #pragma system_include         /* treat file as system include file for MISRA check */
  27:Drivers/CMSIS/Include/core_cm0.h **** #elif defined (__clang__)
  28:Drivers/CMSIS/Include/core_cm0.h ****   #pragma clang system_header   /* treat file as system include file */
  29:Drivers/CMSIS/Include/core_cm0.h **** #endif
  30:Drivers/CMSIS/Include/core_cm0.h **** 
  31:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_GENERIC
  32:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_GENERIC
  33:Drivers/CMSIS/Include/core_cm0.h **** 
  34:Drivers/CMSIS/Include/core_cm0.h **** #include <stdint.h>
  35:Drivers/CMSIS/Include/core_cm0.h **** 
  36:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
  37:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
  38:Drivers/CMSIS/Include/core_cm0.h **** #endif
  39:Drivers/CMSIS/Include/core_cm0.h **** 
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 9


  40:Drivers/CMSIS/Include/core_cm0.h **** /**
  41:Drivers/CMSIS/Include/core_cm0.h ****   \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
  42:Drivers/CMSIS/Include/core_cm0.h ****   CMSIS violates the following MISRA-C:2004 rules:
  43:Drivers/CMSIS/Include/core_cm0.h **** 
  44:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 8.5, object/function definition in header file.<br>
  45:Drivers/CMSIS/Include/core_cm0.h ****      Function definitions in header files are used to allow 'inlining'.
  46:Drivers/CMSIS/Include/core_cm0.h **** 
  47:Drivers/CMSIS/Include/core_cm0.h ****    \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
  48:Drivers/CMSIS/Include/core_cm0.h ****      Unions are used for effective representation of core registers.
  49:Drivers/CMSIS/Include/core_cm0.h **** 
  50:Drivers/CMSIS/Include/core_cm0.h ****    \li Advisory Rule 19.7, Function-like macro defined.<br>
  51:Drivers/CMSIS/Include/core_cm0.h ****      Function-like macros are used to allow more efficient code.
  52:Drivers/CMSIS/Include/core_cm0.h ****  */
  53:Drivers/CMSIS/Include/core_cm0.h **** 
  54:Drivers/CMSIS/Include/core_cm0.h **** 
  55:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
  56:Drivers/CMSIS/Include/core_cm0.h ****  *                 CMSIS definitions
  57:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
  58:Drivers/CMSIS/Include/core_cm0.h **** /**
  59:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup Cortex_M0
  60:Drivers/CMSIS/Include/core_cm0.h ****   @{
  61:Drivers/CMSIS/Include/core_cm0.h ****  */
  62:Drivers/CMSIS/Include/core_cm0.h **** 
  63:Drivers/CMSIS/Include/core_cm0.h **** #include "cmsis_version.h"
  64:Drivers/CMSIS/Include/core_cm0.h ****  
  65:Drivers/CMSIS/Include/core_cm0.h **** /*  CMSIS CM0 definitions */
  66:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] C
  67:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  C
  68:Drivers/CMSIS/Include/core_cm0.h **** #define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
  69:Drivers/CMSIS/Include/core_cm0.h ****                                     __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL
  70:Drivers/CMSIS/Include/core_cm0.h **** 
  71:Drivers/CMSIS/Include/core_cm0.h **** #define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
  72:Drivers/CMSIS/Include/core_cm0.h **** 
  73:Drivers/CMSIS/Include/core_cm0.h **** /** __FPU_USED indicates whether an FPU is used or not.
  74:Drivers/CMSIS/Include/core_cm0.h ****     This core does not support an FPU at all
  75:Drivers/CMSIS/Include/core_cm0.h **** */
  76:Drivers/CMSIS/Include/core_cm0.h **** #define __FPU_USED       0U
  77:Drivers/CMSIS/Include/core_cm0.h **** 
  78:Drivers/CMSIS/Include/core_cm0.h **** #if defined ( __CC_ARM )
  79:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TARGET_FPU_VFP
  80:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  81:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  82:Drivers/CMSIS/Include/core_cm0.h **** 
  83:Drivers/CMSIS/Include/core_cm0.h **** #elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
  84:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARM_PCS_VFP
  85:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  86:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  87:Drivers/CMSIS/Include/core_cm0.h **** 
  88:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __GNUC__ )
  89:Drivers/CMSIS/Include/core_cm0.h ****   #if defined (__VFP_FP__) && !defined(__SOFTFP__)
  90:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  91:Drivers/CMSIS/Include/core_cm0.h ****   #endif
  92:Drivers/CMSIS/Include/core_cm0.h **** 
  93:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __ICCARM__ )
  94:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __ARMVFP__
  95:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
  96:Drivers/CMSIS/Include/core_cm0.h ****   #endif
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 10


  97:Drivers/CMSIS/Include/core_cm0.h **** 
  98:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TI_ARM__ )
  99:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __TI_VFP_SUPPORT__
 100:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 101:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 102:Drivers/CMSIS/Include/core_cm0.h **** 
 103:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __TASKING__ )
 104:Drivers/CMSIS/Include/core_cm0.h ****   #if defined __FPU_VFP__
 105:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 106:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 107:Drivers/CMSIS/Include/core_cm0.h **** 
 108:Drivers/CMSIS/Include/core_cm0.h **** #elif defined ( __CSMC__ )
 109:Drivers/CMSIS/Include/core_cm0.h ****   #if ( __CSMC__ & 0x400U)
 110:Drivers/CMSIS/Include/core_cm0.h ****     #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
 111:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 112:Drivers/CMSIS/Include/core_cm0.h **** 
 113:Drivers/CMSIS/Include/core_cm0.h **** #endif
 114:Drivers/CMSIS/Include/core_cm0.h **** 
 115:Drivers/CMSIS/Include/core_cm0.h **** #include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
 116:Drivers/CMSIS/Include/core_cm0.h **** 
 117:Drivers/CMSIS/Include/core_cm0.h **** 
 118:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 119:Drivers/CMSIS/Include/core_cm0.h **** }
 120:Drivers/CMSIS/Include/core_cm0.h **** #endif
 121:Drivers/CMSIS/Include/core_cm0.h **** 
 122:Drivers/CMSIS/Include/core_cm0.h **** #endif /* __CORE_CM0_H_GENERIC */
 123:Drivers/CMSIS/Include/core_cm0.h **** 
 124:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CMSIS_GENERIC
 125:Drivers/CMSIS/Include/core_cm0.h **** 
 126:Drivers/CMSIS/Include/core_cm0.h **** #ifndef __CORE_CM0_H_DEPENDANT
 127:Drivers/CMSIS/Include/core_cm0.h **** #define __CORE_CM0_H_DEPENDANT
 128:Drivers/CMSIS/Include/core_cm0.h **** 
 129:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 130:Drivers/CMSIS/Include/core_cm0.h ****  extern "C" {
 131:Drivers/CMSIS/Include/core_cm0.h **** #endif
 132:Drivers/CMSIS/Include/core_cm0.h **** 
 133:Drivers/CMSIS/Include/core_cm0.h **** /* check device defines and use defaults */
 134:Drivers/CMSIS/Include/core_cm0.h **** #if defined __CHECK_DEVICE_DEFINES
 135:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __CM0_REV
 136:Drivers/CMSIS/Include/core_cm0.h ****     #define __CM0_REV               0x0000U
 137:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__CM0_REV not defined in device header file; using default!"
 138:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 139:Drivers/CMSIS/Include/core_cm0.h **** 
 140:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __NVIC_PRIO_BITS
 141:Drivers/CMSIS/Include/core_cm0.h ****     #define __NVIC_PRIO_BITS          2U
 142:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
 143:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 144:Drivers/CMSIS/Include/core_cm0.h **** 
 145:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef __Vendor_SysTickConfig
 146:Drivers/CMSIS/Include/core_cm0.h ****     #define __Vendor_SysTickConfig    0U
 147:Drivers/CMSIS/Include/core_cm0.h ****     #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
 148:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 149:Drivers/CMSIS/Include/core_cm0.h **** #endif
 150:Drivers/CMSIS/Include/core_cm0.h **** 
 151:Drivers/CMSIS/Include/core_cm0.h **** /* IO definitions (access restrictions to peripheral registers) */
 152:Drivers/CMSIS/Include/core_cm0.h **** /**
 153:Drivers/CMSIS/Include/core_cm0.h ****     \defgroup CMSIS_glob_defs CMSIS Global Defines
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 11


 154:Drivers/CMSIS/Include/core_cm0.h **** 
 155:Drivers/CMSIS/Include/core_cm0.h ****     <strong>IO Type Qualifiers</strong> are used
 156:Drivers/CMSIS/Include/core_cm0.h ****     \li to specify the access to peripheral variables.
 157:Drivers/CMSIS/Include/core_cm0.h ****     \li for automatic generation of peripheral register debug information.
 158:Drivers/CMSIS/Include/core_cm0.h **** */
 159:Drivers/CMSIS/Include/core_cm0.h **** #ifdef __cplusplus
 160:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile             /*!< Defines 'read only' permissions */
 161:Drivers/CMSIS/Include/core_cm0.h **** #else
 162:Drivers/CMSIS/Include/core_cm0.h ****   #define   __I     volatile const       /*!< Defines 'read only' permissions */
 163:Drivers/CMSIS/Include/core_cm0.h **** #endif
 164:Drivers/CMSIS/Include/core_cm0.h **** #define     __O     volatile             /*!< Defines 'write only' permissions */
 165:Drivers/CMSIS/Include/core_cm0.h **** #define     __IO    volatile             /*!< Defines 'read / write' permissions */
 166:Drivers/CMSIS/Include/core_cm0.h **** 
 167:Drivers/CMSIS/Include/core_cm0.h **** /* following defines should be used for structure members */
 168:Drivers/CMSIS/Include/core_cm0.h **** #define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
 169:Drivers/CMSIS/Include/core_cm0.h **** #define     __OM     volatile            /*! Defines 'write only' structure member permissions */
 170:Drivers/CMSIS/Include/core_cm0.h **** #define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
 171:Drivers/CMSIS/Include/core_cm0.h **** 
 172:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group Cortex_M0 */
 173:Drivers/CMSIS/Include/core_cm0.h **** 
 174:Drivers/CMSIS/Include/core_cm0.h **** 
 175:Drivers/CMSIS/Include/core_cm0.h **** 
 176:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 177:Drivers/CMSIS/Include/core_cm0.h ****  *                 Register Abstraction
 178:Drivers/CMSIS/Include/core_cm0.h ****   Core Register contain:
 179:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register
 180:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Register
 181:Drivers/CMSIS/Include/core_cm0.h ****   - Core SCB Register
 182:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Register
 183:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 184:Drivers/CMSIS/Include/core_cm0.h **** /**
 185:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_core_register Defines and Type Definitions
 186:Drivers/CMSIS/Include/core_cm0.h ****   \brief Type definitions and defines for Cortex-M processor based devices.
 187:Drivers/CMSIS/Include/core_cm0.h **** */
 188:Drivers/CMSIS/Include/core_cm0.h **** 
 189:Drivers/CMSIS/Include/core_cm0.h **** /**
 190:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 191:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_CORE  Status and Control Registers
 192:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Core Register type definitions.
 193:Drivers/CMSIS/Include/core_cm0.h ****   @{
 194:Drivers/CMSIS/Include/core_cm0.h ****  */
 195:Drivers/CMSIS/Include/core_cm0.h **** 
 196:Drivers/CMSIS/Include/core_cm0.h **** /**
 197:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Application Program Status Register (APSR).
 198:Drivers/CMSIS/Include/core_cm0.h ****  */
 199:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 200:Drivers/CMSIS/Include/core_cm0.h **** {
 201:Drivers/CMSIS/Include/core_cm0.h ****   struct
 202:Drivers/CMSIS/Include/core_cm0.h ****   {
 203:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
 204:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 205:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 206:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 207:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 208:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 209:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 210:Drivers/CMSIS/Include/core_cm0.h **** } APSR_Type;
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 12


 211:Drivers/CMSIS/Include/core_cm0.h **** 
 212:Drivers/CMSIS/Include/core_cm0.h **** /* APSR Register Definitions */
 213:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Pos                         31U                                            /*!< APSR
 214:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR
 215:Drivers/CMSIS/Include/core_cm0.h **** 
 216:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Pos                         30U                                            /*!< APSR
 217:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR
 218:Drivers/CMSIS/Include/core_cm0.h **** 
 219:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Pos                         29U                                            /*!< APSR
 220:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR
 221:Drivers/CMSIS/Include/core_cm0.h **** 
 222:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Pos                         28U                                            /*!< APSR
 223:Drivers/CMSIS/Include/core_cm0.h **** #define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR
 224:Drivers/CMSIS/Include/core_cm0.h **** 
 225:Drivers/CMSIS/Include/core_cm0.h **** 
 226:Drivers/CMSIS/Include/core_cm0.h **** /**
 227:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Interrupt Program Status Register (IPSR).
 228:Drivers/CMSIS/Include/core_cm0.h ****  */
 229:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 230:Drivers/CMSIS/Include/core_cm0.h **** {
 231:Drivers/CMSIS/Include/core_cm0.h ****   struct
 232:Drivers/CMSIS/Include/core_cm0.h ****   {
 233:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 234:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
 235:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 236:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 237:Drivers/CMSIS/Include/core_cm0.h **** } IPSR_Type;
 238:Drivers/CMSIS/Include/core_cm0.h **** 
 239:Drivers/CMSIS/Include/core_cm0.h **** /* IPSR Register Definitions */
 240:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Pos                        0U                                            /*!< IPSR
 241:Drivers/CMSIS/Include/core_cm0.h **** #define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR
 242:Drivers/CMSIS/Include/core_cm0.h **** 
 243:Drivers/CMSIS/Include/core_cm0.h **** 
 244:Drivers/CMSIS/Include/core_cm0.h **** /**
 245:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
 246:Drivers/CMSIS/Include/core_cm0.h ****  */
 247:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 248:Drivers/CMSIS/Include/core_cm0.h **** {
 249:Drivers/CMSIS/Include/core_cm0.h ****   struct
 250:Drivers/CMSIS/Include/core_cm0.h ****   {
 251:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
 252:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
 253:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
 254:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
 255:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
 256:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
 257:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
 258:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
 259:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 260:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 261:Drivers/CMSIS/Include/core_cm0.h **** } xPSR_Type;
 262:Drivers/CMSIS/Include/core_cm0.h **** 
 263:Drivers/CMSIS/Include/core_cm0.h **** /* xPSR Register Definitions */
 264:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Pos                         31U                                            /*!< xPSR
 265:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR
 266:Drivers/CMSIS/Include/core_cm0.h **** 
 267:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Pos                         30U                                            /*!< xPSR
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 13


 268:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR
 269:Drivers/CMSIS/Include/core_cm0.h **** 
 270:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Pos                         29U                                            /*!< xPSR
 271:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR
 272:Drivers/CMSIS/Include/core_cm0.h **** 
 273:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Pos                         28U                                            /*!< xPSR
 274:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR
 275:Drivers/CMSIS/Include/core_cm0.h **** 
 276:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Pos                         24U                                            /*!< xPSR
 277:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR
 278:Drivers/CMSIS/Include/core_cm0.h **** 
 279:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Pos                        0U                                            /*!< xPSR
 280:Drivers/CMSIS/Include/core_cm0.h **** #define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR
 281:Drivers/CMSIS/Include/core_cm0.h **** 
 282:Drivers/CMSIS/Include/core_cm0.h **** 
 283:Drivers/CMSIS/Include/core_cm0.h **** /**
 284:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Union type to access the Control Registers (CONTROL).
 285:Drivers/CMSIS/Include/core_cm0.h ****  */
 286:Drivers/CMSIS/Include/core_cm0.h **** typedef union
 287:Drivers/CMSIS/Include/core_cm0.h **** {
 288:Drivers/CMSIS/Include/core_cm0.h ****   struct
 289:Drivers/CMSIS/Include/core_cm0.h ****   {
 290:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
 291:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
 292:Drivers/CMSIS/Include/core_cm0.h ****     uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
 293:Drivers/CMSIS/Include/core_cm0.h ****   } b;                                   /*!< Structure used for bit  access */
 294:Drivers/CMSIS/Include/core_cm0.h ****   uint32_t w;                            /*!< Type      used for word access */
 295:Drivers/CMSIS/Include/core_cm0.h **** } CONTROL_Type;
 296:Drivers/CMSIS/Include/core_cm0.h **** 
 297:Drivers/CMSIS/Include/core_cm0.h **** /* CONTROL Register Definitions */
 298:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Pos                   1U                                            /*!< CONT
 299:Drivers/CMSIS/Include/core_cm0.h **** #define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONT
 300:Drivers/CMSIS/Include/core_cm0.h **** 
 301:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CORE */
 302:Drivers/CMSIS/Include/core_cm0.h **** 
 303:Drivers/CMSIS/Include/core_cm0.h **** 
 304:Drivers/CMSIS/Include/core_cm0.h **** /**
 305:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 306:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
 307:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Type definitions for the NVIC Registers
 308:Drivers/CMSIS/Include/core_cm0.h ****   @{
 309:Drivers/CMSIS/Include/core_cm0.h ****  */
 310:Drivers/CMSIS/Include/core_cm0.h **** 
 311:Drivers/CMSIS/Include/core_cm0.h **** /**
 312:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
 313:Drivers/CMSIS/Include/core_cm0.h ****  */
 314:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 315:Drivers/CMSIS/Include/core_cm0.h **** {
 316:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
 317:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0[31U];
 318:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register 
 319:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RSERVED1[31U];
 320:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register *
 321:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED2[31U];
 322:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register
 323:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED3[31U];
 324:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED4[64U];
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 14


 325:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
 326:Drivers/CMSIS/Include/core_cm0.h **** }  NVIC_Type;
 327:Drivers/CMSIS/Include/core_cm0.h **** 
 328:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_NVIC */
 329:Drivers/CMSIS/Include/core_cm0.h **** 
 330:Drivers/CMSIS/Include/core_cm0.h **** 
 331:Drivers/CMSIS/Include/core_cm0.h **** /**
 332:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 333:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SCB     System Control Block (SCB)
 334:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Control Block Registers
 335:Drivers/CMSIS/Include/core_cm0.h ****   @{
 336:Drivers/CMSIS/Include/core_cm0.h ****  */
 337:Drivers/CMSIS/Include/core_cm0.h **** 
 338:Drivers/CMSIS/Include/core_cm0.h **** /**
 339:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Control Block (SCB).
 340:Drivers/CMSIS/Include/core_cm0.h ****  */
 341:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 342:Drivers/CMSIS/Include/core_cm0.h **** {
 343:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
 344:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Regi
 345:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED0;
 346:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset 
 347:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
 348:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register *
 349:Drivers/CMSIS/Include/core_cm0.h ****         uint32_t RESERVED1;
 350:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registe
 351:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State
 352:Drivers/CMSIS/Include/core_cm0.h **** } SCB_Type;
 353:Drivers/CMSIS/Include/core_cm0.h **** 
 354:Drivers/CMSIS/Include/core_cm0.h **** /* SCB CPUID Register Definitions */
 355:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB 
 356:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB 
 357:Drivers/CMSIS/Include/core_cm0.h **** 
 358:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB 
 359:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB 
 360:Drivers/CMSIS/Include/core_cm0.h **** 
 361:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB 
 362:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB 
 363:Drivers/CMSIS/Include/core_cm0.h **** 
 364:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB 
 365:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB 
 366:Drivers/CMSIS/Include/core_cm0.h **** 
 367:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB 
 368:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB 
 369:Drivers/CMSIS/Include/core_cm0.h **** 
 370:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Interrupt Control State Register Definitions */
 371:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB 
 372:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB 
 373:Drivers/CMSIS/Include/core_cm0.h **** 
 374:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB 
 375:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB 
 376:Drivers/CMSIS/Include/core_cm0.h **** 
 377:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB 
 378:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB 
 379:Drivers/CMSIS/Include/core_cm0.h **** 
 380:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB 
 381:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB 
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 15


 382:Drivers/CMSIS/Include/core_cm0.h **** 
 383:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB 
 384:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB 
 385:Drivers/CMSIS/Include/core_cm0.h **** 
 386:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB 
 387:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB 
 388:Drivers/CMSIS/Include/core_cm0.h **** 
 389:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB 
 390:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB 
 391:Drivers/CMSIS/Include/core_cm0.h **** 
 392:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB 
 393:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB 
 394:Drivers/CMSIS/Include/core_cm0.h **** 
 395:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB 
 396:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB 
 397:Drivers/CMSIS/Include/core_cm0.h **** 
 398:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Application Interrupt and Reset Control Register Definitions */
 399:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB 
 400:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB 
 401:Drivers/CMSIS/Include/core_cm0.h **** 
 402:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB 
 403:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB 
 404:Drivers/CMSIS/Include/core_cm0.h **** 
 405:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB 
 406:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB 
 407:Drivers/CMSIS/Include/core_cm0.h **** 
 408:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB 
 409:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB 
 410:Drivers/CMSIS/Include/core_cm0.h **** 
 411:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB 
 412:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB 
 413:Drivers/CMSIS/Include/core_cm0.h **** 
 414:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Control Register Definitions */
 415:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB 
 416:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB 
 417:Drivers/CMSIS/Include/core_cm0.h **** 
 418:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB 
 419:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB 
 420:Drivers/CMSIS/Include/core_cm0.h **** 
 421:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB 
 422:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB 
 423:Drivers/CMSIS/Include/core_cm0.h **** 
 424:Drivers/CMSIS/Include/core_cm0.h **** /* SCB Configuration Control Register Definitions */
 425:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB 
 426:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB 
 427:Drivers/CMSIS/Include/core_cm0.h **** 
 428:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB 
 429:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB 
 430:Drivers/CMSIS/Include/core_cm0.h **** 
 431:Drivers/CMSIS/Include/core_cm0.h **** /* SCB System Handler Control and State Register Definitions */
 432:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB 
 433:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB 
 434:Drivers/CMSIS/Include/core_cm0.h **** 
 435:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SCB */
 436:Drivers/CMSIS/Include/core_cm0.h **** 
 437:Drivers/CMSIS/Include/core_cm0.h **** 
 438:Drivers/CMSIS/Include/core_cm0.h **** /**
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 16


 439:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 440:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
 441:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Type definitions for the System Timer Registers.
 442:Drivers/CMSIS/Include/core_cm0.h ****   @{
 443:Drivers/CMSIS/Include/core_cm0.h ****  */
 444:Drivers/CMSIS/Include/core_cm0.h **** 
 445:Drivers/CMSIS/Include/core_cm0.h **** /**
 446:Drivers/CMSIS/Include/core_cm0.h ****   \brief  Structure type to access the System Timer (SysTick).
 447:Drivers/CMSIS/Include/core_cm0.h ****  */
 448:Drivers/CMSIS/Include/core_cm0.h **** typedef struct
 449:Drivers/CMSIS/Include/core_cm0.h **** {
 450:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Regis
 451:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
 452:Drivers/CMSIS/Include/core_cm0.h ****   __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register *
 453:Drivers/CMSIS/Include/core_cm0.h ****   __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
 454:Drivers/CMSIS/Include/core_cm0.h **** } SysTick_Type;
 455:Drivers/CMSIS/Include/core_cm0.h **** 
 456:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Control / Status Register Definitions */
 457:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysT
 458:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysT
 459:Drivers/CMSIS/Include/core_cm0.h **** 
 460:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysT
 461:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysT
 462:Drivers/CMSIS/Include/core_cm0.h **** 
 463:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysT
 464:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysT
 465:Drivers/CMSIS/Include/core_cm0.h **** 
 466:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysT
 467:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysT
 468:Drivers/CMSIS/Include/core_cm0.h **** 
 469:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Reload Register Definitions */
 470:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysT
 471:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysT
 472:Drivers/CMSIS/Include/core_cm0.h **** 
 473:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Current Register Definitions */
 474:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysT
 475:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysT
 476:Drivers/CMSIS/Include/core_cm0.h **** 
 477:Drivers/CMSIS/Include/core_cm0.h **** /* SysTick Calibration Register Definitions */
 478:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysT
 479:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysT
 480:Drivers/CMSIS/Include/core_cm0.h **** 
 481:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysT
 482:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysT
 483:Drivers/CMSIS/Include/core_cm0.h **** 
 484:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysT
 485:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysT
 486:Drivers/CMSIS/Include/core_cm0.h **** 
 487:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_SysTick */
 488:Drivers/CMSIS/Include/core_cm0.h **** 
 489:Drivers/CMSIS/Include/core_cm0.h **** 
 490:Drivers/CMSIS/Include/core_cm0.h **** /**
 491:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_core_register
 492:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
 493:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible ove
 494:Drivers/CMSIS/Include/core_cm0.h ****             Therefore they are not covered by the Cortex-M0 header file.
 495:Drivers/CMSIS/Include/core_cm0.h ****   @{
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 17


 496:Drivers/CMSIS/Include/core_cm0.h ****  */
 497:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_CoreDebug */
 498:Drivers/CMSIS/Include/core_cm0.h **** 
 499:Drivers/CMSIS/Include/core_cm0.h **** 
 500:Drivers/CMSIS/Include/core_cm0.h **** /**
 501:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 502:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_bitfield     Core register bit field macros
 503:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
 504:Drivers/CMSIS/Include/core_cm0.h ****   @{
 505:Drivers/CMSIS/Include/core_cm0.h ****  */
 506:Drivers/CMSIS/Include/core_cm0.h **** 
 507:Drivers/CMSIS/Include/core_cm0.h **** /**
 508:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Mask and shift a bit field value for use in a register bit range.
 509:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 510:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
 511:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted value.
 512:Drivers/CMSIS/Include/core_cm0.h **** */
 513:Drivers/CMSIS/Include/core_cm0.h **** #define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
 514:Drivers/CMSIS/Include/core_cm0.h **** 
 515:Drivers/CMSIS/Include/core_cm0.h **** /**
 516:Drivers/CMSIS/Include/core_cm0.h ****   \brief     Mask and shift a register value to extract a bit filed value.
 517:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] field  Name of the register bit field.
 518:Drivers/CMSIS/Include/core_cm0.h ****   \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
 519:Drivers/CMSIS/Include/core_cm0.h ****   \return           Masked and shifted bit field value.
 520:Drivers/CMSIS/Include/core_cm0.h **** */
 521:Drivers/CMSIS/Include/core_cm0.h **** #define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
 522:Drivers/CMSIS/Include/core_cm0.h **** 
 523:Drivers/CMSIS/Include/core_cm0.h **** /*@} end of group CMSIS_core_bitfield */
 524:Drivers/CMSIS/Include/core_cm0.h **** 
 525:Drivers/CMSIS/Include/core_cm0.h **** 
 526:Drivers/CMSIS/Include/core_cm0.h **** /**
 527:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup    CMSIS_core_register
 528:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup   CMSIS_core_base     Core Definitions
 529:Drivers/CMSIS/Include/core_cm0.h ****   \brief      Definitions for base addresses, unions, and structures.
 530:Drivers/CMSIS/Include/core_cm0.h ****   @{
 531:Drivers/CMSIS/Include/core_cm0.h ****  */
 532:Drivers/CMSIS/Include/core_cm0.h **** 
 533:Drivers/CMSIS/Include/core_cm0.h **** /* Memory mapping of Core Hardware */
 534:Drivers/CMSIS/Include/core_cm0.h **** #define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Bas
 535:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
 536:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
 537:Drivers/CMSIS/Include/core_cm0.h **** #define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Bas
 538:Drivers/CMSIS/Include/core_cm0.h **** 
 539:Drivers/CMSIS/Include/core_cm0.h **** #define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct
 540:Drivers/CMSIS/Include/core_cm0.h **** #define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration st
 541:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struc
 542:Drivers/CMSIS/Include/core_cm0.h **** 
 543:Drivers/CMSIS/Include/core_cm0.h **** 
 544:Drivers/CMSIS/Include/core_cm0.h **** /*@} */
 545:Drivers/CMSIS/Include/core_cm0.h **** 
 546:Drivers/CMSIS/Include/core_cm0.h **** 
 547:Drivers/CMSIS/Include/core_cm0.h **** 
 548:Drivers/CMSIS/Include/core_cm0.h **** /*******************************************************************************
 549:Drivers/CMSIS/Include/core_cm0.h ****  *                Hardware Abstraction Layer
 550:Drivers/CMSIS/Include/core_cm0.h ****   Core Function Interface contains:
 551:Drivers/CMSIS/Include/core_cm0.h ****   - Core NVIC Functions
 552:Drivers/CMSIS/Include/core_cm0.h ****   - Core SysTick Functions
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 18


 553:Drivers/CMSIS/Include/core_cm0.h ****   - Core Register Access Functions
 554:Drivers/CMSIS/Include/core_cm0.h ****  ******************************************************************************/
 555:Drivers/CMSIS/Include/core_cm0.h **** /**
 556:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
 557:Drivers/CMSIS/Include/core_cm0.h **** */
 558:Drivers/CMSIS/Include/core_cm0.h **** 
 559:Drivers/CMSIS/Include/core_cm0.h **** 
 560:Drivers/CMSIS/Include/core_cm0.h **** 
 561:Drivers/CMSIS/Include/core_cm0.h **** /* ##########################   NVIC functions  #################################### */
 562:Drivers/CMSIS/Include/core_cm0.h **** /**
 563:Drivers/CMSIS/Include/core_cm0.h ****   \ingroup  CMSIS_Core_FunctionInterface
 564:Drivers/CMSIS/Include/core_cm0.h ****   \defgroup CMSIS_Core_NVICFunctions NVIC Functions
 565:Drivers/CMSIS/Include/core_cm0.h ****   \brief    Functions that manage interrupts and exceptions via the NVIC.
 566:Drivers/CMSIS/Include/core_cm0.h ****   @{
 567:Drivers/CMSIS/Include/core_cm0.h ****  */
 568:Drivers/CMSIS/Include/core_cm0.h **** 
 569:Drivers/CMSIS/Include/core_cm0.h **** #ifdef CMSIS_NVIC_VIRTUAL
 570:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
 571:Drivers/CMSIS/Include/core_cm0.h ****     #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
 572:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 573:Drivers/CMSIS/Include/core_cm0.h ****   #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
 574:Drivers/CMSIS/Include/core_cm0.h **** #else
 575:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
 576:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
 577:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_EnableIRQ              __NVIC_EnableIRQ
 578:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
 579:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_DisableIRQ             __NVIC_DisableIRQ
 580:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
 581:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
 582:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
 583:Drivers/CMSIS/Include/core_cm0.h **** /*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
 584:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetPriority            __NVIC_SetPriority
 585:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetPriority            __NVIC_GetPriority
 586:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SystemReset            __NVIC_SystemReset
 587:Drivers/CMSIS/Include/core_cm0.h **** #endif /* CMSIS_NVIC_VIRTUAL */
 588:Drivers/CMSIS/Include/core_cm0.h **** 
 589:Drivers/CMSIS/Include/core_cm0.h **** #ifdef CMSIS_VECTAB_VIRTUAL
 590:Drivers/CMSIS/Include/core_cm0.h ****   #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 591:Drivers/CMSIS/Include/core_cm0.h ****     #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
 592:Drivers/CMSIS/Include/core_cm0.h ****   #endif
 593:Drivers/CMSIS/Include/core_cm0.h ****   #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
 594:Drivers/CMSIS/Include/core_cm0.h **** #else
 595:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_SetVector              __NVIC_SetVector
 596:Drivers/CMSIS/Include/core_cm0.h ****   #define NVIC_GetVector              __NVIC_GetVector
 597:Drivers/CMSIS/Include/core_cm0.h **** #endif  /* (CMSIS_VECTAB_VIRTUAL) */
 598:Drivers/CMSIS/Include/core_cm0.h **** 
 599:Drivers/CMSIS/Include/core_cm0.h **** #define NVIC_USER_IRQ_OFFSET          16
 600:Drivers/CMSIS/Include/core_cm0.h **** 
 601:Drivers/CMSIS/Include/core_cm0.h **** 
 602:Drivers/CMSIS/Include/core_cm0.h **** /* The following EXC_RETURN values are saved the LR on exception entry */
 603:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after ret
 604:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after retu
 605:Drivers/CMSIS/Include/core_cm0.h **** #define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after retu
 606:Drivers/CMSIS/Include/core_cm0.h **** 
 607:Drivers/CMSIS/Include/core_cm0.h **** 
 608:Drivers/CMSIS/Include/core_cm0.h **** /* Interrupt Priorities are WORD accessible only under Armv6-M                  */
 609:Drivers/CMSIS/Include/core_cm0.h **** /* The following MACROS handle generation of the register offset and byte masks */
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 19


 610:Drivers/CMSIS/Include/core_cm0.h **** #define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
 611:Drivers/CMSIS/Include/core_cm0.h **** #define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
 612:Drivers/CMSIS/Include/core_cm0.h **** #define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
 613:Drivers/CMSIS/Include/core_cm0.h **** 
 614:Drivers/CMSIS/Include/core_cm0.h **** #define __NVIC_SetPriorityGrouping(X) (void)(X)
 615:Drivers/CMSIS/Include/core_cm0.h **** #define __NVIC_GetPriorityGrouping()  (0U)
 616:Drivers/CMSIS/Include/core_cm0.h **** 
 617:Drivers/CMSIS/Include/core_cm0.h **** /**
 618:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Enable Interrupt
 619:Drivers/CMSIS/Include/core_cm0.h ****   \details Enables a device specific interrupt in the NVIC interrupt controller.
 620:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 621:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 622:Drivers/CMSIS/Include/core_cm0.h ****  */
 623:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
 317              		.loc 2 623 22 view .LVU88
 318              	.LBB7:
 624:Drivers/CMSIS/Include/core_cm0.h **** {
 625:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 319              		.loc 2 625 3 view .LVU89
 626:Drivers/CMSIS/Include/core_cm0.h ****   {
 627:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 320              		.loc 2 627 5 view .LVU90
 321              		.loc 2 627 20 is_stmt 0 view .LVU91
 322 007e 0F4B     		ldr	r3, .L9+32
 323 0080 8022     		movs	r2, #128
 324 0082 9202     		lsls	r2, r2, #10
 325 0084 1A60     		str	r2, [r3]
 326              	.LVL4:
 327              		.loc 2 627 20 view .LVU92
 328              	.LBE7:
 329              	.LBE6:
 107:Src/motor.c   ****     NVIC_SetPriority(TIM6_DAC_IRQn,2);
 330              		.loc 1 107 5 is_stmt 1 view .LVU93
 331              	.LBB8:
 332              	.LBI8:
 628:Drivers/CMSIS/Include/core_cm0.h ****   }
 629:Drivers/CMSIS/Include/core_cm0.h **** }
 630:Drivers/CMSIS/Include/core_cm0.h **** 
 631:Drivers/CMSIS/Include/core_cm0.h **** 
 632:Drivers/CMSIS/Include/core_cm0.h **** /**
 633:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Interrupt Enable status
 634:Drivers/CMSIS/Include/core_cm0.h ****   \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
 635:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 636:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt is not enabled.
 637:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt is enabled.
 638:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 639:Drivers/CMSIS/Include/core_cm0.h ****  */
 640:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
 641:Drivers/CMSIS/Include/core_cm0.h **** {
 642:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 643:Drivers/CMSIS/Include/core_cm0.h ****   {
 644:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL)
 645:Drivers/CMSIS/Include/core_cm0.h ****   }
 646:Drivers/CMSIS/Include/core_cm0.h ****   else
 647:Drivers/CMSIS/Include/core_cm0.h ****   {
 648:Drivers/CMSIS/Include/core_cm0.h ****     return(0U);
 649:Drivers/CMSIS/Include/core_cm0.h ****   }
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 20


 650:Drivers/CMSIS/Include/core_cm0.h **** }
 651:Drivers/CMSIS/Include/core_cm0.h **** 
 652:Drivers/CMSIS/Include/core_cm0.h **** 
 653:Drivers/CMSIS/Include/core_cm0.h **** /**
 654:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Disable Interrupt
 655:Drivers/CMSIS/Include/core_cm0.h ****   \details Disables a device specific interrupt in the NVIC interrupt controller.
 656:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 657:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 658:Drivers/CMSIS/Include/core_cm0.h ****  */
 659:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
 660:Drivers/CMSIS/Include/core_cm0.h **** {
 661:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 662:Drivers/CMSIS/Include/core_cm0.h ****   {
 663:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 664:Drivers/CMSIS/Include/core_cm0.h ****     __DSB();
 665:Drivers/CMSIS/Include/core_cm0.h ****     __ISB();
 666:Drivers/CMSIS/Include/core_cm0.h ****   }
 667:Drivers/CMSIS/Include/core_cm0.h **** }
 668:Drivers/CMSIS/Include/core_cm0.h **** 
 669:Drivers/CMSIS/Include/core_cm0.h **** 
 670:Drivers/CMSIS/Include/core_cm0.h **** /**
 671:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Get Pending Interrupt
 672:Drivers/CMSIS/Include/core_cm0.h ****   \details Reads the NVIC pending register and returns the pending bit for the specified device spe
 673:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 674:Drivers/CMSIS/Include/core_cm0.h ****   \return             0  Interrupt status is not pending.
 675:Drivers/CMSIS/Include/core_cm0.h ****   \return             1  Interrupt status is pending.
 676:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 677:Drivers/CMSIS/Include/core_cm0.h ****  */
 678:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
 679:Drivers/CMSIS/Include/core_cm0.h **** {
 680:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 681:Drivers/CMSIS/Include/core_cm0.h ****   {
 682:Drivers/CMSIS/Include/core_cm0.h ****     return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL)
 683:Drivers/CMSIS/Include/core_cm0.h ****   }
 684:Drivers/CMSIS/Include/core_cm0.h ****   else
 685:Drivers/CMSIS/Include/core_cm0.h ****   {
 686:Drivers/CMSIS/Include/core_cm0.h ****     return(0U);
 687:Drivers/CMSIS/Include/core_cm0.h ****   }
 688:Drivers/CMSIS/Include/core_cm0.h **** }
 689:Drivers/CMSIS/Include/core_cm0.h **** 
 690:Drivers/CMSIS/Include/core_cm0.h **** 
 691:Drivers/CMSIS/Include/core_cm0.h **** /**
 692:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Pending Interrupt
 693:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
 694:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 695:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 696:Drivers/CMSIS/Include/core_cm0.h ****  */
 697:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
 698:Drivers/CMSIS/Include/core_cm0.h **** {
 699:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 700:Drivers/CMSIS/Include/core_cm0.h ****   {
 701:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 702:Drivers/CMSIS/Include/core_cm0.h ****   }
 703:Drivers/CMSIS/Include/core_cm0.h **** }
 704:Drivers/CMSIS/Include/core_cm0.h **** 
 705:Drivers/CMSIS/Include/core_cm0.h **** 
 706:Drivers/CMSIS/Include/core_cm0.h **** /**
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 21


 707:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Clear Pending Interrupt
 708:Drivers/CMSIS/Include/core_cm0.h ****   \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
 709:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Device specific interrupt number.
 710:Drivers/CMSIS/Include/core_cm0.h ****   \note    IRQn must not be negative.
 711:Drivers/CMSIS/Include/core_cm0.h ****  */
 712:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
 713:Drivers/CMSIS/Include/core_cm0.h **** {
 714:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 715:Drivers/CMSIS/Include/core_cm0.h ****   {
 716:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 717:Drivers/CMSIS/Include/core_cm0.h ****   }
 718:Drivers/CMSIS/Include/core_cm0.h **** }
 719:Drivers/CMSIS/Include/core_cm0.h **** 
 720:Drivers/CMSIS/Include/core_cm0.h **** 
 721:Drivers/CMSIS/Include/core_cm0.h **** /**
 722:Drivers/CMSIS/Include/core_cm0.h ****   \brief   Set Interrupt Priority
 723:Drivers/CMSIS/Include/core_cm0.h ****   \details Sets the priority of a device specific interrupt or a processor exception.
 724:Drivers/CMSIS/Include/core_cm0.h ****            The interrupt number can be positive to specify a device specific interrupt,
 725:Drivers/CMSIS/Include/core_cm0.h ****            or negative to specify a processor exception.
 726:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]      IRQn  Interrupt number.
 727:Drivers/CMSIS/Include/core_cm0.h ****   \param [in]  priority  Priority to set.
 728:Drivers/CMSIS/Include/core_cm0.h ****   \note    The priority cannot be set for every processor exception.
 729:Drivers/CMSIS/Include/core_cm0.h ****  */
 730:Drivers/CMSIS/Include/core_cm0.h **** __STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
 333              		.loc 2 730 22 view .LVU94
 334              	.LBB9:
 731:Drivers/CMSIS/Include/core_cm0.h **** {
 732:Drivers/CMSIS/Include/core_cm0.h ****   if ((int32_t)(IRQn) >= 0)
 335              		.loc 2 732 3 view .LVU95
 733:Drivers/CMSIS/Include/core_cm0.h ****   {
 734:Drivers/CMSIS/Include/core_cm0.h ****     NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))
 336              		.loc 2 734 5 view .LVU96
 337              		.loc 2 734 52 is_stmt 0 view .LVU97
 338 0086 C420     		movs	r0, #196
 339 0088 8000     		lsls	r0, r0, #2
 340 008a 1A58     		ldr	r2, [r3, r0]
 341              		.loc 2 734 33 view .LVU98
 342 008c 0C49     		ldr	r1, .L9+36
 343 008e 1140     		ands	r1, r2
 344              		.loc 2 734 102 view .LVU99
 345 0090 8022     		movs	r2, #128
 346 0092 1202     		lsls	r2, r2, #8
 347 0094 0A43     		orrs	r2, r1
 348              		.loc 2 734 30 view .LVU100
 349 0096 1A50     		str	r2, [r3, r0]
 350              	.LVL5:
 351              		.loc 2 734 30 view .LVU101
 352              	.LBE9:
 353              	.LBE8:
 108:Src/motor.c   **** }
 354              		.loc 1 108 1 view .LVU102
 355              		@ sp needed
 356 0098 7047     		bx	lr
 357              	.L10:
 358 009a C046     		.align	2
 359              	.L9:
 360 009c 00100240 		.word	1073876992
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 22


 361 00a0 00040048 		.word	1207960576
 362 00a4 FFFAFFFF 		.word	-1281
 363 00a8 00040040 		.word	1073742848
 364 00ac FFFF0000 		.word	65535
 365 00b0 FF7F0000 		.word	32767
 366 00b4 00100040 		.word	1073745920
 367 00b8 30750000 		.word	30000
 368 00bc 00E100E0 		.word	-536813312
 369 00c0 FF00FFFF 		.word	-65281
 370              		.cfi_endproc
 371              	.LFE46:
 373              		.section	.text.ADC_init,"ax",%progbits
 374              		.align	1
 375              		.global	ADC_init
 376              		.syntax unified
 377              		.code	16
 378              		.thumb_func
 379              		.fpu softvfp
 381              	ADC_init:
 382              	.LFB48:
 109:Src/motor.c   **** 
 110:Src/motor.c   **** // Encoder interrupt to calculate motor speed, also manages PI controller
 111:Src/motor.c   **** void TIM6_DAC_IRQHandler(void) {
 112:Src/motor.c   ****     /* Calculate the motor speed in raw encoder counts
 113:Src/motor.c   ****      * Note the motor speed is signed! Motor can be run in reverse.
 114:Src/motor.c   ****      * Speed is measured by how far the counter moved from center point
 115:Src/motor.c   ****      */
 116:Src/motor.c   ****     motor_speed = (TIM3->CNT - 0x7FFF);
 117:Src/motor.c   ****     TIM3->CNT = 0x7FFF; // Reset back to center point
 118:Src/motor.c   ****     
 119:Src/motor.c   ****     // Call the PI update function
 120:Src/motor.c   ****     PI_update();
 121:Src/motor.c   **** 
 122:Src/motor.c   ****     TIM6->SR &= ~TIM_SR_UIF;        // Acknowledge the interrupt
 123:Src/motor.c   **** }
 124:Src/motor.c   **** 
 125:Src/motor.c   **** void ADC_init(void) {
 383              		.loc 1 125 21 is_stmt 1 view -0
 384              		.cfi_startproc
 385              		@ args = 0, pretend = 0, frame = 0
 386              		@ frame_needed = 0, uses_anonymous_args = 0
 387              		@ link register save eliminated.
 126:Src/motor.c   **** 
 127:Src/motor.c   ****     // Configure PA1 for ADC input (used for current monitoring)
 128:Src/motor.c   ****     GPIOA->MODER |= (GPIO_MODER_MODER1_0 | GPIO_MODER_MODER1_1);
 388              		.loc 1 128 5 view .LVU104
 389              		.loc 1 128 18 is_stmt 0 view .LVU105
 390 0000 9022     		movs	r2, #144
 391 0002 D205     		lsls	r2, r2, #23
 392 0004 1368     		ldr	r3, [r2]
 393 0006 0C21     		movs	r1, #12
 394 0008 0B43     		orrs	r3, r1
 395 000a 1360     		str	r3, [r2]
 129:Src/motor.c   **** 
 130:Src/motor.c   ****     // Configure ADC to 8-bit continuous-run mode, (asynchronous clock mode)
 131:Src/motor.c   ****     RCC->APB2ENR |= RCC_APB2ENR_ADCEN;
 396              		.loc 1 131 5 is_stmt 1 view .LVU106
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 23


 397              		.loc 1 131 18 is_stmt 0 view .LVU107
 398 000c 154A     		ldr	r2, .L14
 399 000e 9169     		ldr	r1, [r2, #24]
 400 0010 8023     		movs	r3, #128
 401 0012 9B00     		lsls	r3, r3, #2
 402 0014 0B43     		orrs	r3, r1
 403 0016 9361     		str	r3, [r2, #24]
 132:Src/motor.c   **** 
 133:Src/motor.c   ****     ADC1->CFGR1 = 0;                        // Default resolution is 12-bit (RES[1:0] = 00 --> 12-b
 404              		.loc 1 133 5 is_stmt 1 view .LVU108
 405              		.loc 1 133 17 is_stmt 0 view .LVU109
 406 0018 134B     		ldr	r3, .L14+4
 407 001a 0021     		movs	r1, #0
 408 001c D960     		str	r1, [r3, #12]
 134:Src/motor.c   ****     ADC1->CFGR1 |= ADC_CFGR1_CONT;          // Set to continuous mode
 409              		.loc 1 134 5 is_stmt 1 view .LVU110
 410              		.loc 1 134 17 is_stmt 0 view .LVU111
 411 001e D868     		ldr	r0, [r3, #12]
 412 0020 8022     		movs	r2, #128
 413 0022 9201     		lsls	r2, r2, #6
 414 0024 0243     		orrs	r2, r0
 415 0026 DA60     		str	r2, [r3, #12]
 135:Src/motor.c   ****     ADC1->CHSELR |= ADC_CHSELR_CHSEL1;      // Enable channel 1
 416              		.loc 1 135 5 is_stmt 1 view .LVU112
 417              		.loc 1 135 18 is_stmt 0 view .LVU113
 418 0028 9A6A     		ldr	r2, [r3, #40]
 419 002a 0220     		movs	r0, #2
 420 002c 0243     		orrs	r2, r0
 421 002e 9A62     		str	r2, [r3, #40]
 136:Src/motor.c   **** 
 137:Src/motor.c   ****     ADC1->CR = 0;
 422              		.loc 1 137 5 is_stmt 1 view .LVU114
 423              		.loc 1 137 14 is_stmt 0 view .LVU115
 424 0030 9960     		str	r1, [r3, #8]
 138:Src/motor.c   ****     ADC1->CR |= ADC_CR_ADCAL;               // Perform self calibration
 425              		.loc 1 138 5 is_stmt 1 view .LVU116
 426              		.loc 1 138 14 is_stmt 0 view .LVU117
 427 0032 9968     		ldr	r1, [r3, #8]
 428 0034 8022     		movs	r2, #128
 429 0036 1206     		lsls	r2, r2, #24
 430 0038 0A43     		orrs	r2, r1
 431 003a 9A60     		str	r2, [r3, #8]
 139:Src/motor.c   ****     while(ADC1->CR & ADC_CR_ADCAL);         // Delay until calibration is complete
 432              		.loc 1 139 5 is_stmt 1 view .LVU118
 433              	.L12:
 434              		.loc 1 139 35 discriminator 1 view .LVU119
 435              		.loc 1 139 10 discriminator 1 view .LVU120
 436              		.loc 1 139 15 is_stmt 0 discriminator 1 view .LVU121
 437 003c 0A4B     		ldr	r3, .L14+4
 438 003e 9B68     		ldr	r3, [r3, #8]
 439              		.loc 1 139 10 discriminator 1 view .LVU122
 440 0040 002B     		cmp	r3, #0
 441 0042 FBDB     		blt	.L12
 140:Src/motor.c   **** 
 141:Src/motor.c   ****     ADC1->CR |= ADC_CR_ADEN;                // Enable ADC
 442              		.loc 1 141 5 is_stmt 1 view .LVU123
 443              		.loc 1 141 14 is_stmt 0 view .LVU124
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 24


 444 0044 084A     		ldr	r2, .L14+4
 445 0046 9368     		ldr	r3, [r2, #8]
 446 0048 0121     		movs	r1, #1
 447 004a 0B43     		orrs	r3, r1
 448 004c 9360     		str	r3, [r2, #8]
 142:Src/motor.c   ****     while(!(ADC1->ISR & ADC_ISR_ADRDY));    // Wait until ADC ready
 449              		.loc 1 142 5 is_stmt 1 view .LVU125
 450              	.L13:
 451              		.loc 1 142 40 discriminator 1 view .LVU126
 452              		.loc 1 142 10 discriminator 1 view .LVU127
 453              		.loc 1 142 17 is_stmt 0 discriminator 1 view .LVU128
 454 004e 064B     		ldr	r3, .L14+4
 455 0050 1B68     		ldr	r3, [r3]
 456              		.loc 1 142 10 discriminator 1 view .LVU129
 457 0052 DB07     		lsls	r3, r3, #31
 458 0054 FBD5     		bpl	.L13
 143:Src/motor.c   ****     ADC1->CR |= ADC_CR_ADSTART;             // Signal conversion start
 459              		.loc 1 143 5 is_stmt 1 view .LVU130
 460              		.loc 1 143 14 is_stmt 0 view .LVU131
 461 0056 044A     		ldr	r2, .L14+4
 462 0058 9368     		ldr	r3, [r2, #8]
 463 005a 0421     		movs	r1, #4
 464 005c 0B43     		orrs	r3, r1
 465 005e 9360     		str	r3, [r2, #8]
 144:Src/motor.c   **** }
 466              		.loc 1 144 1 view .LVU132
 467              		@ sp needed
 468 0060 7047     		bx	lr
 469              	.L15:
 470 0062 C046     		.align	2
 471              	.L14:
 472 0064 00100240 		.word	1073876992
 473 0068 00240140 		.word	1073816576
 474              		.cfi_endproc
 475              	.LFE48:
 477              		.section	.text.motor_init,"ax",%progbits
 478              		.align	1
 479              		.global	motor_init
 480              		.syntax unified
 481              		.code	16
 482              		.thumb_func
 483              		.fpu softvfp
 485              	motor_init:
 486              	.LFB43:
  17:Src/motor.c   ****     pwm_init();
 487              		.loc 1 17 23 is_stmt 1 view -0
 488              		.cfi_startproc
 489              		@ args = 0, pretend = 0, frame = 0
 490              		@ frame_needed = 0, uses_anonymous_args = 0
 491 0000 10B5     		push	{r4, lr}
 492              	.LCFI1:
 493              		.cfi_def_cfa_offset 8
 494              		.cfi_offset 4, -8
 495              		.cfi_offset 14, -4
  18:Src/motor.c   ****     encoder_init();
 496              		.loc 1 18 5 view .LVU134
 497 0002 FFF7FEFF 		bl	pwm_init
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 25


 498              	.LVL6:
  19:Src/motor.c   ****     ADC_init();
 499              		.loc 1 19 5 view .LVU135
 500 0006 FFF7FEFF 		bl	encoder_init
 501              	.LVL7:
  20:Src/motor.c   **** }
 502              		.loc 1 20 5 view .LVU136
 503 000a FFF7FEFF 		bl	ADC_init
 504              	.LVL8:
  21:Src/motor.c   **** 
 505              		.loc 1 21 1 is_stmt 0 view .LVU137
 506              		@ sp needed
 507 000e 10BD     		pop	{r4, pc}
 508              		.cfi_endproc
 509              	.LFE43:
 511              		.section	.text.PI_update,"ax",%progbits
 512              		.align	1
 513              		.global	PI_update
 514              		.syntax unified
 515              		.code	16
 516              		.thumb_func
 517              		.fpu softvfp
 519              	PI_update:
 520              	.LFB49:
 145:Src/motor.c   **** 
 146:Src/motor.c   **** void PI_update(void) {
 521              		.loc 1 146 22 is_stmt 1 view -0
 522              		.cfi_startproc
 523              		@ args = 0, pretend = 0, frame = 0
 524              		@ frame_needed = 0, uses_anonymous_args = 0
 525 0000 10B5     		push	{r4, lr}
 526              	.LCFI2:
 527              		.cfi_def_cfa_offset 8
 528              		.cfi_offset 4, -8
 529              		.cfi_offset 14, -4
 147:Src/motor.c   ****     
 148:Src/motor.c   ****     /* Run PI control loop
 149:Src/motor.c   ****      *
 150:Src/motor.c   ****      * Make sure to use the indicated variable names. This allows STMStudio to monitor
 151:Src/motor.c   ****      * the condition of the system!
 152:Src/motor.c   ****      *
 153:Src/motor.c   ****      * target_rpm -> target motor speed in RPM
 154:Src/motor.c   ****      * motor_speed -> raw motor speed in encoder counts
 155:Src/motor.c   ****      * error -> error signal (difference between measured speed and target)
 156:Src/motor.c   ****      * error_integral -> integrated error signal
 157:Src/motor.c   ****      * Kp -> Proportional Gain
 158:Src/motor.c   ****      * Ki -> Integral Gain
 159:Src/motor.c   ****      * output -> raw output signal from PI controller
 160:Src/motor.c   ****      * duty_cycle -> used to report the duty cycle of the system 
 161:Src/motor.c   ****      * adc_value -> raw ADC counts to report current
 162:Src/motor.c   ****      *
 163:Src/motor.c   ****      */
 164:Src/motor.c   ****     
 165:Src/motor.c   ****     /// TODO: calculate error signal and write to "error" variable
 166:Src/motor.c   ****     
 167:Src/motor.c   ****     /* Hint: Remember that your calculated motor speed may not be directly in RPM!
 168:Src/motor.c   ****      *       You will need to convert the target or encoder speeds to the same units.
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 26


 169:Src/motor.c   ****      *       I recommend converting to whatever units result in larger values, gives
 170:Src/motor.c   ****      *       more resolution.
 171:Src/motor.c   ****      */
 172:Src/motor.c   ****     
 173:Src/motor.c   ****     error = (target_rpm * 2) - motor_speed;
 530              		.loc 1 173 5 view .LVU139
 531              		.loc 1 173 25 is_stmt 0 view .LVU140
 532 0002 294B     		ldr	r3, .L25
 533 0004 1B88     		ldrh	r3, [r3]
 534 0006 1BB2     		sxth	r3, r3
 535 0008 5B00     		lsls	r3, r3, #1
 536 000a 9BB2     		uxth	r3, r3
 537              		.loc 1 173 30 view .LVU141
 538 000c 274A     		ldr	r2, .L25+4
 539 000e 1288     		ldrh	r2, [r2]
 540 0010 12B2     		sxth	r2, r2
 541 0012 9B1A     		subs	r3, r3, r2
 542 0014 1BB2     		sxth	r3, r3
 543              		.loc 1 173 11 view .LVU142
 544 0016 264A     		ldr	r2, .L25+8
 545 0018 1380     		strh	r3, [r2]
 174:Src/motor.c   ****     
 175:Src/motor.c   ****     /// TODO: Calculate integral portion of PI controller, write to "error_integral" variable
 176:Src/motor.c   ****     
 177:Src/motor.c   ****     error_integral = error_integral + (Ki * error);
 546              		.loc 1 177 5 is_stmt 1 view .LVU143
 547              		.loc 1 177 37 is_stmt 0 view .LVU144
 548 001a 264B     		ldr	r3, .L25+12
 549 001c 1B78     		ldrb	r3, [r3]
 550 001e 1088     		ldrh	r0, [r2]
 551 0020 00B2     		sxth	r0, r0
 552 0022 254A     		ldr	r2, .L25+16
 553 0024 1188     		ldrh	r1, [r2]
 554 0026 09B2     		sxth	r1, r1
 555 0028 4343     		muls	r3, r0
 556 002a 5B18     		adds	r3, r3, r1
 557 002c 1BB2     		sxth	r3, r3
 558              		.loc 1 177 20 view .LVU145
 559 002e 1380     		strh	r3, [r2]
 178:Src/motor.c   **** 
 179:Src/motor.c   ****     /// TODO: Clamp the value of the integral to a limited positive range
 180:Src/motor.c   ****     
 181:Src/motor.c   ****     if (error_integral < 0)
 560              		.loc 1 181 5 is_stmt 1 view .LVU146
 561              		.loc 1 181 24 is_stmt 0 view .LVU147
 562 0030 1388     		ldrh	r3, [r2]
 563 0032 1BB2     		sxth	r3, r3
 564              		.loc 1 181 8 view .LVU148
 565 0034 002B     		cmp	r3, #0
 566 0036 1FDB     		blt	.L24
 567              	.L18:
 182:Src/motor.c   ****         error_integral = 0;
 183:Src/motor.c   ****     if (error_integral > 3200)
 568              		.loc 1 183 5 is_stmt 1 view .LVU149
 569              		.loc 1 183 24 is_stmt 0 view .LVU150
 570 0038 1F4B     		ldr	r3, .L25+16
 571 003a 1B88     		ldrh	r3, [r3]
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 27


 572 003c 1BB2     		sxth	r3, r3
 573              		.loc 1 183 8 view .LVU151
 574 003e C822     		movs	r2, #200
 575 0040 1201     		lsls	r2, r2, #4
 576 0042 9342     		cmp	r3, r2
 577 0044 01DD     		ble	.L19
 184:Src/motor.c   ****         error_integral = 3200;
 578              		.loc 1 184 9 is_stmt 1 view .LVU152
 579              		.loc 1 184 24 is_stmt 0 view .LVU153
 580 0046 1C4B     		ldr	r3, .L25+16
 581 0048 1A80     		strh	r2, [r3]
 582              	.L19:
 185:Src/motor.c   **** 
 186:Src/motor.c   ****     /* Hint: The value clamp is needed to prevent excessive "windup" in the integral.
 187:Src/motor.c   ****      *       You'll read more about this for the post-lab. The exact value is arbitrary
 188:Src/motor.c   ****      *       but affects the PI tuning.
 189:Src/motor.c   ****      *       Recommend that you clamp between 0 and 3200 (what is used in the lab solution)
 190:Src/motor.c   ****      */
 191:Src/motor.c   ****     
 192:Src/motor.c   ****     /// TODO: Calculate proportional portion, add integral and write to "output" variable
 193:Src/motor.c   **** 
 194:Src/motor.c   ****     int16_t output = Kp * error + error_integral; // Change this!
 583              		.loc 1 194 5 is_stmt 1 view .LVU154
 584              		.loc 1 194 33 is_stmt 0 view .LVU155
 585 004a 1C4B     		ldr	r3, .L25+20
 586 004c 1B78     		ldrb	r3, [r3]
 587 004e 184A     		ldr	r2, .L25+8
 588 0050 1188     		ldrh	r1, [r2]
 589 0052 09B2     		sxth	r1, r1
 590 0054 184A     		ldr	r2, .L25+16
 591 0056 1288     		ldrh	r2, [r2]
 592 0058 12B2     		sxth	r2, r2
 593 005a 4B43     		muls	r3, r1
 594 005c 9B18     		adds	r3, r3, r2
 595              		.loc 1 194 13 view .LVU156
 596 005e 1BB2     		sxth	r3, r3
 597              	.LVL9:
 195:Src/motor.c   ****     
 196:Src/motor.c   ****     /* Because the calculated values for the PI controller are significantly larger than 
 197:Src/motor.c   ****      * the allowable range for duty cycle, you'll need to divide the result down into 
 198:Src/motor.c   ****      * an appropriate range. (Maximum integral clamp / X = 100% duty cycle)
 199:Src/motor.c   ****      * 
 200:Src/motor.c   ****      * Hint: If you chose 3200 for the integral clamp you should divide by 32 (right shift by 5 bit
 201:Src/motor.c   ****      *       this will give you an output of 100 at maximum integral "windup".
 202:Src/motor.c   ****      *
 203:Src/motor.c   ****      * This division also turns the above calculations into pseudo fixed-point. This is because
 204:Src/motor.c   ****      * the lowest 5 bits act as if they were below the decimal point until the division where they
 205:Src/motor.c   ****      * were truncated off to result in an integer value. 
 206:Src/motor.c   ****      *
 207:Src/motor.c   ****      * Technically most of this is arbitrary, in a real system you would want to use a fixed-point
 208:Src/motor.c   ****      * math library. The main difference that these values make is the difference in the gain value
 209:Src/motor.c   ****      * required for tuning.
 210:Src/motor.c   ****      */
 211:Src/motor.c   **** 
 212:Src/motor.c   ****      /// TODO: Divide the output into the proper range for output adjustment
 213:Src/motor.c   ****      
 214:Src/motor.c   ****     output = output >> 5;
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 28


 598              		.loc 1 214 5 is_stmt 1 view .LVU157
 599              		.loc 1 214 12 is_stmt 0 view .LVU158
 600 0060 5A11     		asrs	r2, r3, #5
 601              	.LVL10:
 215:Src/motor.c   **** 
 216:Src/motor.c   ****      /// TODO: Clamp the output value between 0 and 100 
 217:Src/motor.c   ****     if (output < 0 || target_rpm == 0)
 602              		.loc 1 217 5 is_stmt 1 view .LVU159
 603              		.loc 1 217 8 is_stmt 0 view .LVU160
 604 0062 002B     		cmp	r3, #0
 605 0064 0CDB     		blt	.L22
 606              		.loc 1 217 34 discriminator 1 view .LVU161
 607 0066 104B     		ldr	r3, .L25
 608 0068 1C88     		ldrh	r4, [r3]
 609 006a 24B2     		sxth	r4, r4
 610              		.loc 1 217 20 discriminator 1 view .LVU162
 611 006c 002C     		cmp	r4, #0
 612 006e 08D0     		beq	.L20
 218:Src/motor.c   ****         output = 0;
 219:Src/motor.c   ****     if (output > 100)
 613              		.loc 1 219 5 is_stmt 1 view .LVU163
 614              		.loc 1 219 8 is_stmt 0 view .LVU164
 615 0070 642A     		cmp	r2, #100
 616 0072 16DC     		bgt	.L23
 214:Src/motor.c   **** 
 617              		.loc 1 214 12 view .LVU165
 618 0074 1400     		movs	r4, r2
 619 0076 04E0     		b	.L20
 620              	.LVL11:
 621              	.L24:
 182:Src/motor.c   ****     if (error_integral > 3200)
 622              		.loc 1 182 9 is_stmt 1 view .LVU166
 182:Src/motor.c   ****     if (error_integral > 3200)
 623              		.loc 1 182 24 is_stmt 0 view .LVU167
 624 0078 1300     		movs	r3, r2
 625 007a 0022     		movs	r2, #0
 626 007c 1A80     		strh	r2, [r3]
 627 007e DBE7     		b	.L18
 628              	.LVL12:
 629              	.L22:
 218:Src/motor.c   ****         output = 0;
 630              		.loc 1 218 16 view .LVU168
 631 0080 0024     		movs	r4, #0
 632              	.L20:
 633              	.LVL13:
 220:Src/motor.c   ****         output = 100;
 221:Src/motor.c   **** 
 222:Src/motor.c   ****     pwm_setDutyCycle(output);
 634              		.loc 1 222 5 is_stmt 1 view .LVU169
 635 0082 E4B2     		uxtb	r4, r4
 636              	.LVL14:
 637              		.loc 1 222 5 is_stmt 0 view .LVU170
 638 0084 2000     		movs	r0, r4
 639 0086 FFF7FEFF 		bl	pwm_setDutyCycle
 640              	.LVL15:
 223:Src/motor.c   ****     duty_cycle = output;            // For debug viewing
 641              		.loc 1 223 5 is_stmt 1 view .LVU171
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 29


 642              		.loc 1 223 16 is_stmt 0 view .LVU172
 643 008a 0D4B     		ldr	r3, .L25+24
 644 008c 1C70     		strb	r4, [r3]
 224:Src/motor.c   **** 
 225:Src/motor.c   ****     // Read the ADC value for current monitoring, actual conversion into meaningful units 
 226:Src/motor.c   ****     // will be performed by STMStudio
 227:Src/motor.c   ****     if(ADC1->ISR & ADC_ISR_EOC) {   // If the ADC has new data for us
 645              		.loc 1 227 5 is_stmt 1 view .LVU173
 646              		.loc 1 227 12 is_stmt 0 view .LVU174
 647 008e 0D4B     		ldr	r3, .L25+28
 648 0090 1B68     		ldr	r3, [r3]
 649              		.loc 1 227 7 view .LVU175
 650 0092 5B07     		lsls	r3, r3, #29
 651 0094 04D5     		bpl	.L17
 228:Src/motor.c   ****         adc_value = ADC1->DR;       // Read the motor current for debug viewing
 652              		.loc 1 228 9 is_stmt 1 view .LVU176
 653              		.loc 1 228 25 is_stmt 0 view .LVU177
 654 0096 0B4B     		ldr	r3, .L25+28
 655 0098 1B6C     		ldr	r3, [r3, #64]
 656              		.loc 1 228 19 view .LVU178
 657 009a 5BB2     		sxtb	r3, r3
 658 009c 0A4A     		ldr	r2, .L25+32
 659 009e 1370     		strb	r3, [r2]
 660              	.L17:
 229:Src/motor.c   ****     }
 230:Src/motor.c   **** }
 661              		.loc 1 230 1 view .LVU179
 662              		@ sp needed
 663 00a0 10BD     		pop	{r4, pc}
 664              	.LVL16:
 665              	.L23:
 220:Src/motor.c   **** 
 666              		.loc 1 220 16 view .LVU180
 667 00a2 6424     		movs	r4, #100
 668 00a4 EDE7     		b	.L20
 669              	.L26:
 670 00a6 C046     		.align	2
 671              	.L25:
 672 00a8 00000000 		.word	.LANCHOR0
 673 00ac 00000000 		.word	.LANCHOR1
 674 00b0 00000000 		.word	.LANCHOR2
 675 00b4 00000000 		.word	.LANCHOR3
 676 00b8 00000000 		.word	.LANCHOR4
 677 00bc 00000000 		.word	.LANCHOR5
 678 00c0 00000000 		.word	.LANCHOR6
 679 00c4 00240140 		.word	1073816576
 680 00c8 00000000 		.word	.LANCHOR7
 681              		.cfi_endproc
 682              	.LFE49:
 684              		.section	.text.TIM6_DAC_IRQHandler,"ax",%progbits
 685              		.align	1
 686              		.global	TIM6_DAC_IRQHandler
 687              		.syntax unified
 688              		.code	16
 689              		.thumb_func
 690              		.fpu softvfp
 692              	TIM6_DAC_IRQHandler:
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 30


 693              	.LFB47:
 111:Src/motor.c   ****     /* Calculate the motor speed in raw encoder counts
 694              		.loc 1 111 32 is_stmt 1 view -0
 695              		.cfi_startproc
 696              		@ args = 0, pretend = 0, frame = 0
 697              		@ frame_needed = 0, uses_anonymous_args = 0
 698 0000 10B5     		push	{r4, lr}
 699              	.LCFI3:
 700              		.cfi_def_cfa_offset 8
 701              		.cfi_offset 4, -8
 702              		.cfi_offset 14, -4
 116:Src/motor.c   ****     TIM3->CNT = 0x7FFF; // Reset back to center point
 703              		.loc 1 116 5 view .LVU182
 116:Src/motor.c   ****     TIM3->CNT = 0x7FFF; // Reset back to center point
 704              		.loc 1 116 24 is_stmt 0 view .LVU183
 705 0002 094A     		ldr	r2, .L28
 706 0004 536A     		ldr	r3, [r2, #36]
 116:Src/motor.c   ****     TIM3->CNT = 0x7FFF; // Reset back to center point
 707              		.loc 1 116 30 view .LVU184
 708 0006 0949     		ldr	r1, .L28+4
 709 0008 8C46     		mov	ip, r1
 710 000a 6344     		add	r3, r3, ip
 711 000c 1BB2     		sxth	r3, r3
 116:Src/motor.c   ****     TIM3->CNT = 0x7FFF; // Reset back to center point
 712              		.loc 1 116 17 view .LVU185
 713 000e 0849     		ldr	r1, .L28+8
 714 0010 0B80     		strh	r3, [r1]
 117:Src/motor.c   ****     
 715              		.loc 1 117 5 is_stmt 1 view .LVU186
 117:Src/motor.c   ****     
 716              		.loc 1 117 15 is_stmt 0 view .LVU187
 717 0012 084B     		ldr	r3, .L28+12
 718 0014 5362     		str	r3, [r2, #36]
 120:Src/motor.c   **** 
 719              		.loc 1 120 5 is_stmt 1 view .LVU188
 720 0016 FFF7FEFF 		bl	PI_update
 721              	.LVL17:
 122:Src/motor.c   **** }
 722              		.loc 1 122 5 view .LVU189
 122:Src/motor.c   **** }
 723              		.loc 1 122 14 is_stmt 0 view .LVU190
 724 001a 074A     		ldr	r2, .L28+16
 725 001c 1369     		ldr	r3, [r2, #16]
 726 001e 0121     		movs	r1, #1
 727 0020 8B43     		bics	r3, r1
 728 0022 1361     		str	r3, [r2, #16]
 123:Src/motor.c   **** 
 729              		.loc 1 123 1 view .LVU191
 730              		@ sp needed
 731 0024 10BD     		pop	{r4, pc}
 732              	.L29:
 733 0026 C046     		.align	2
 734              	.L28:
 735 0028 00040040 		.word	1073742848
 736 002c 0180FFFF 		.word	-32767
 737 0030 00000000 		.word	.LANCHOR1
 738 0034 FF7F0000 		.word	32767
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 31


 739 0038 00100040 		.word	1073745920
 740              		.cfi_endproc
 741              	.LFE47:
 743              		.global	Ki
 744              		.global	Kp
 745              		.global	error
 746              		.global	adc_value
 747              		.global	motor_speed
 748              		.global	target_rpm
 749              		.global	duty_cycle
 750              		.global	error_integral
 751              		.section	.bss.adc_value,"aw",%nobits
 752              		.set	.LANCHOR7,. + 0
 755              	adc_value:
 756 0000 00       		.space	1
 757              		.section	.bss.duty_cycle,"aw",%nobits
 758              		.set	.LANCHOR6,. + 0
 761              	duty_cycle:
 762 0000 00       		.space	1
 763              		.section	.bss.error,"aw",%nobits
 764              		.align	1
 765              		.set	.LANCHOR2,. + 0
 768              	error:
 769 0000 0000     		.space	2
 770              		.section	.bss.error_integral,"aw",%nobits
 771              		.align	1
 772              		.set	.LANCHOR4,. + 0
 775              	error_integral:
 776 0000 0000     		.space	2
 777              		.section	.bss.motor_speed,"aw",%nobits
 778              		.align	1
 779              		.set	.LANCHOR1,. + 0
 782              	motor_speed:
 783 0000 0000     		.space	2
 784              		.section	.bss.target_rpm,"aw",%nobits
 785              		.align	1
 786              		.set	.LANCHOR0,. + 0
 789              	target_rpm:
 790 0000 0000     		.space	2
 791              		.section	.data.Ki,"aw"
 792              		.set	.LANCHOR3,. + 0
 795              	Ki:
 796 0000 0A       		.byte	10
 797              		.section	.data.Kp,"aw"
 798              		.set	.LANCHOR5,. + 0
 801              	Kp:
 802 0000 0A       		.byte	10
 803              		.text
 804              	.Letext0:
 805              		.file 3 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 806              		.file 4 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\lib\\gcc\\arm-none
 807              		.file 5 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 808              		.file 6 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 809              		.file 7 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 810              		.file 8 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 811              		.file 9 "c:\\program files (x86)\\gnu arm embedded toolchain\\9 2020-q2-update\\arm-none-eabi\\inc
 812              		.file 10 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/stm32f072xb.h"
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 32


 813              		.file 11 "Drivers/CMSIS/Device/ST/STM32F0xx/Include/system_stm32f0xx.h"
 814              		.file 12 "Drivers/STM32F0xx_HAL_Driver/Inc/stm32f0xx_hal.h"
 815              		.file 13 "Inc/motor.h"
ARM GAS  C:\Users\adman\AppData\Local\Temp\cci2aHHu.s 			page 33


DEFINED SYMBOLS
                            *ABS*:00000000 motor.c
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:16     .text.pwm_init:00000000 $t
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:24     .text.pwm_init:00000000 pwm_init
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:138    .text.pwm_init:00000084 $d
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:148    .text.pwm_setDutyCycle:00000000 $t
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:155    .text.pwm_setDutyCycle:00000000 pwm_setDutyCycle
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:192    .text.pwm_setDutyCycle:00000018 $d
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:197    .text.encoder_init:00000000 $t
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:204    .text.encoder_init:00000000 encoder_init
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:360    .text.encoder_init:0000009c $d
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:374    .text.ADC_init:00000000 $t
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:381    .text.ADC_init:00000000 ADC_init
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:472    .text.ADC_init:00000064 $d
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:478    .text.motor_init:00000000 $t
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:485    .text.motor_init:00000000 motor_init
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:512    .text.PI_update:00000000 $t
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:519    .text.PI_update:00000000 PI_update
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:672    .text.PI_update:000000a8 $d
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:685    .text.TIM6_DAC_IRQHandler:00000000 $t
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:692    .text.TIM6_DAC_IRQHandler:00000000 TIM6_DAC_IRQHandler
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:735    .text.TIM6_DAC_IRQHandler:00000028 $d
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:795    .data.Ki:00000000 Ki
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:801    .data.Kp:00000000 Kp
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:768    .bss.error:00000000 error
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:755    .bss.adc_value:00000000 adc_value
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:782    .bss.motor_speed:00000000 motor_speed
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:789    .bss.target_rpm:00000000 target_rpm
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:761    .bss.duty_cycle:00000000 duty_cycle
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:775    .bss.error_integral:00000000 error_integral
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:756    .bss.adc_value:00000000 $d
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:762    .bss.duty_cycle:00000000 $d
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:764    .bss.error:00000000 $d
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:771    .bss.error_integral:00000000 $d
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:778    .bss.motor_speed:00000000 $d
C:\Users\adman\AppData\Local\Temp\cci2aHHu.s:785    .bss.target_rpm:00000000 $d

UNDEFINED SYMBOLS
__aeabi_uidiv
